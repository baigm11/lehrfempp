<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LehrFEM++: lf::refinement::MeshHierarchy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "bm.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// This file defines a number of macros which can be used in 
// formulas of the doxygen documentation.
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      grad: "\\vec{\\operatorname{grad}}"
    }
  }
});
</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LehrFEM++
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">A simple Finite Element Library for teaching</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>lf</b></li><li class="navelem"><a class="el" href="namespacelf_1_1refinement.html">refinement</a></li><li class="navelem"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classlf_1_1refinement_1_1_mesh_hierarchy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lf::refinement::MeshHierarchy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A hierarchy of nested 2D hybrid meshes created by refinement.  
 <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mesh__hierarchy_8h_source.html">mesh_hierarchy.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac2c38516a94d8fb131703b519bfc3738"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac2c38516a94d8fb131703b519bfc3738">MeshHierarchy</a> (std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt; base_mesh, std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html">mesh::MeshFactory</a> &gt; mesh_factory)</td></tr>
<tr class="memdesc:ac2c38516a94d8fb131703b519bfc3738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize mesh hierarchy with an existing coarsest mesh.  <a href="#ac2c38516a94d8fb131703b519bfc3738">More...</a><br /></td></tr>
<tr class="separator:ac2c38516a94d8fb131703b519bfc3738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10de191109487dbf85b47569f0436c14"><td class="memItemLeft" align="right" valign="top"><a id="a10de191109487dbf85b47569f0436c14"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MeshHierarchy</b> (const <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;)=delete</td></tr>
<tr class="separator:a10de191109487dbf85b47569f0436c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc774617bd6c1c960ffaee7026f68fe9"><td class="memItemLeft" align="right" valign="top"><a id="abc774617bd6c1c960ffaee7026f68fe9"></a>
<a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;)=delete</td></tr>
<tr class="separator:abc774617bd6c1c960ffaee7026f68fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac210c02aec4ae49d35e3247fdd8a7621"><td class="memItemLeft" align="right" valign="top"><a id="ac210c02aec4ae49d35e3247fdd8a7621"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MeshHierarchy</b> (<a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac210c02aec4ae49d35e3247fdd8a7621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb411a057bb85d8c585d4ff09edeee7f"><td class="memItemLeft" align="right" valign="top"><a id="adb411a057bb85d8c585d4ff09edeee7f"></a>
<a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:adb411a057bb85d8c585d4ff09edeee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36a331c1ae18dc09cf8eb720feae67a"><td class="memItemLeft" align="right" valign="top"><a id="ac36a331c1ae18dc09cf8eb720feae67a"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac36a331c1ae18dc09cf8eb720feae67a">NumLevels</a> () const</td></tr>
<tr class="memdesc:ac36a331c1ae18dc09cf8eb720feae67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of meshes contained in the hierarchy, 1 for a single mesh <br /></td></tr>
<tr class="separator:ac36a331c1ae18dc09cf8eb720feae67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6af114a5d79f8cf99ed0d501dd417c1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#af6af114a5d79f8cf99ed0d501dd417c1">getMesh</a> (size_type level) const</td></tr>
<tr class="memdesc:af6af114a5d79f8cf99ed0d501dd417c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the mesh on a particular level  <a href="#af6af114a5d79f8cf99ed0d501dd417c1">More...</a><br /></td></tr>
<tr class="separator:af6af114a5d79f8cf99ed0d501dd417c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c5d43197587173c285f2689868bd9d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a94c5d43197587173c285f2689868bd9d">getMesh</a> (size_type level)</td></tr>
<tr class="memdesc:a94c5d43197587173c285f2689868bd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the mesh on a particular level  <a href="#a94c5d43197587173c285f2689868bd9d">More...</a><br /></td></tr>
<tr class="separator:a94c5d43197587173c285f2689868bd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f47c1d0b430311541771d26dceec21"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a43f47c1d0b430311541771d26dceec21">getMeshes</a> () const</td></tr>
<tr class="memdesc:a43f47c1d0b430311541771d26dceec21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides array of shared pointers to meshes contained in the hierarchy.  <a href="#a43f47c1d0b430311541771d26dceec21">More...</a><br /></td></tr>
<tr class="separator:a43f47c1d0b430311541771d26dceec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac538ac9d7b9f1128a251ab17dbd125b7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_point_child_info.html">PointChildInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac538ac9d7b9f1128a251ab17dbd125b7">PointChildInfos</a> (size_type level) const</td></tr>
<tr class="memdesc:ac538ac9d7b9f1128a251ab17dbd125b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain refinement information for all points.  <a href="#ac538ac9d7b9f1128a251ab17dbd125b7">More...</a><br /></td></tr>
<tr class="separator:ac538ac9d7b9f1128a251ab17dbd125b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe86a285de7b155b4eabc7233cba4a5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html">EdgeChildInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a0fe86a285de7b155b4eabc7233cba4a5">EdgeChildInfos</a> (size_type level) const</td></tr>
<tr class="memdesc:a0fe86a285de7b155b4eabc7233cba4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain refinement information for all edges.  <a href="#a0fe86a285de7b155b4eabc7233cba4a5">More...</a><br /></td></tr>
<tr class="separator:a0fe86a285de7b155b4eabc7233cba4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334d3018f4bad589a6a81e52df16e178"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html">CellChildInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a334d3018f4bad589a6a81e52df16e178">CellChildInfos</a> (size_type level) const</td></tr>
<tr class="memdesc:a334d3018f4bad589a6a81e52df16e178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain refinement information for all.  <a href="#a334d3018f4bad589a6a81e52df16e178">More...</a><br /></td></tr>
<tr class="separator:a334d3018f4bad589a6a81e52df16e178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b2981a5c074c72e56c4592a5f253d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_parent_info.html">ParentInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a546b2981a5c074c72e56c4592a5f253d">ParentInfos</a> (size_type level, dim_t codim) const</td></tr>
<tr class="memdesc:a546b2981a5c074c72e56c4592a5f253d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch information about parents.  <a href="#a546b2981a5c074c72e56c4592a5f253d">More...</a><br /></td></tr>
<tr class="separator:a546b2981a5c074c72e56c4592a5f253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae631d3d4b080210e7fe28b0cb18a6a1b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sub_idx_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ae631d3d4b080210e7fe28b0cb18a6a1b">RefinementEdges</a> (size_type level) const</td></tr>
<tr class="memdesc:ae631d3d4b080210e7fe28b0cb18a6a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access refinement edge indices.  <a href="#ae631d3d4b080210e7fe28b0cb18a6a1b">More...</a><br /></td></tr>
<tr class="separator:ae631d3d4b080210e7fe28b0cb18a6a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f62ce5f838a648e584015fc712ab27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a40f62ce5f838a648e584015fc712ab27">RefineRegular</a> (<a class="el" href="namespacelf_1_1refinement.html#aad00cb5a8084400b931b01984d2cdc5d">RefPat</a> ref_pat=RefPat::rp_regular)</td></tr>
<tr class="memdesc:a40f62ce5f838a648e584015fc712ab27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform regular or barycentric uniform refinement of the finest mesh in the hierarchy.  <a href="#a40f62ce5f838a648e584015fc712ab27">More...</a><br /></td></tr>
<tr class="separator:a40f62ce5f838a648e584015fc712ab27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4608cfc81660a615e4a23c1476b7a7d"><td class="memTemplParams" colspan="2">template&lt;typename Marker &gt; </td></tr>
<tr class="memitem:aa4608cfc81660a615e4a23c1476b7a7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#aa4608cfc81660a615e4a23c1476b7a7d">MarkEdges</a> (Marker &amp;&amp;marker)</td></tr>
<tr class="memdesc:aa4608cfc81660a615e4a23c1476b7a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the edges of a mesh based on a predicate.  <a href="#aa4608cfc81660a615e4a23c1476b7a7d">More...</a><br /></td></tr>
<tr class="separator:aa4608cfc81660a615e4a23c1476b7a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d5d31b5aaf0b9e077d890f3062022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a693d5d31b5aaf0b9e077d890f3062022">RefineMarked</a> ()</td></tr>
<tr class="memdesc:a693d5d31b5aaf0b9e077d890f3062022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct local refinement of the mesh splitting all marked edges.  <a href="#a693d5d31b5aaf0b9e077d890f3062022">More...</a><br /></td></tr>
<tr class="separator:a693d5d31b5aaf0b9e077d890f3062022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71cfa216aa13d280d814894811b09b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ab71cfa216aa13d280d814894811b09b2">Coarsen</a> ()</td></tr>
<tr class="memdesc:ab71cfa216aa13d280d814894811b09b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Destroy</em> the mesh on the finest level unless it is the base mesh  <a href="#ab71cfa216aa13d280d814894811b09b2">More...</a><br /></td></tr>
<tr class="separator:ab71cfa216aa13d280d814894811b09b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f54305170974cae0e5b42754bf6d98d"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a9f54305170974cae0e5b42754bf6d98d">PrintInfo</a> (std::ostream &amp;o) const</td></tr>
<tr class="memdesc:a9f54305170974cae0e5b42754bf6d98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output of information about the mesh hierarchy.  <a href="#a9f54305170974cae0e5b42754bf6d98d">More...</a><br /></td></tr>
<tr class="separator:a9f54305170974cae0e5b42754bf6d98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af46f2b1255d3fcd15e30aac0ffbb98d9"><td class="memItemLeft" align="right" valign="top"><a id="af46f2b1255d3fcd15e30aac0ffbb98d9"></a>
static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#af46f2b1255d3fcd15e30aac0ffbb98d9">output_ctrl_</a></td></tr>
<tr class="memdesc:af46f2b1255d3fcd15e30aac0ffbb98d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">diagnostics control variable <br /></td></tr>
<tr class="separator:af46f2b1255d3fcd15e30aac0ffbb98d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f77d2d63daeeaedff7b10ecd6ef40f1"><td class="memItemLeft" align="right" valign="top"><a id="a1f77d2d63daeeaedff7b10ecd6ef40f1"></a>
static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a1f77d2d63daeeaedff7b10ecd6ef40f1">ctrl_</a></td></tr>
<tr class="memdesc:a1f77d2d63daeeaedff7b10ecd6ef40f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control variable. <br /></td></tr>
<tr class="separator:a1f77d2d63daeeaedff7b10ecd6ef40f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de0f442177771c5f118ff6a63e11c67"><td class="memItemLeft" align="right" valign="top"><a id="a4de0f442177771c5f118ff6a63e11c67"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>kout_meshinfo</b> = 2</td></tr>
<tr class="separator:a4de0f442177771c5f118ff6a63e11c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac18f1c6c7d4cca9de0647287913509f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac18f1c6c7d4cca9de0647287913509f8">PerformRefinement</a> ()</td></tr>
<tr class="memdesc:ac18f1c6c7d4cca9de0647287913509f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new mesh according to refinement pattern provided for entities.  <a href="#ac18f1c6c7d4cca9de0647287913509f8">More...</a><br /></td></tr>
<tr class="separator:ac18f1c6c7d4cca9de0647287913509f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a427ec75f53b43f76a2b7e4ef32d86"><td class="memItemLeft" align="right" valign="top">sub_idx_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a26a427ec75f53b43f76a2b7e4ef32d86">LongestEdge</a> (const <a class="el" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a> &amp;T) const</td></tr>
<tr class="memdesc:a26a427ec75f53b43f76a2b7e4ef32d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the longest edge of a triangle.  <a href="#a26a427ec75f53b43f76a2b7e4ef32d86">More...</a><br /></td></tr>
<tr class="separator:a26a427ec75f53b43f76a2b7e4ef32d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7129e3d9cc0581148ba3ae4e8c6c59a0"><td class="memItemLeft" align="right" valign="top"><a id="a7129e3d9cc0581148ba3ae4e8c6c59a0"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a7129e3d9cc0581148ba3ae4e8c6c59a0">meshes_</a></td></tr>
<tr class="memdesc:a7129e3d9cc0581148ba3ae4e8c6c59a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the meshes managed by the <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html" title="A hierarchy of nested 2D hybrid meshes created by refinement. ">MeshHierarchy</a> object <br /></td></tr>
<tr class="separator:a7129e3d9cc0581148ba3ae4e8c6c59a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a03c986a230f6299c30ebc5bb8fc65"><td class="memItemLeft" align="right" valign="top"><a id="a70a03c986a230f6299c30ebc5bb8fc65"></a>
std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html">mesh::MeshFactory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a70a03c986a230f6299c30ebc5bb8fc65">mesh_factory_</a></td></tr>
<tr class="memdesc:a70a03c986a230f6299c30ebc5bb8fc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mesh factory to be used to creating a new mesh. <br /></td></tr>
<tr class="separator:a70a03c986a230f6299c30ebc5bb8fc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1360c31adeee50eed9343513277053e"><td class="memItemLeft" align="right" valign="top"><a id="ab1360c31adeee50eed9343513277053e"></a>
std::vector&lt; std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_point_child_info.html">PointChildInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ab1360c31adeee50eed9343513277053e">point_child_infos_</a></td></tr>
<tr class="memdesc:ab1360c31adeee50eed9343513277053e"><td class="mdescLeft">&#160;</td><td class="mdescRight">information about children of nodes for each level <br /></td></tr>
<tr class="separator:ab1360c31adeee50eed9343513277053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe8cf2492abd66f1404a1bc6365fb11"><td class="memItemLeft" align="right" valign="top"><a id="aebe8cf2492abd66f1404a1bc6365fb11"></a>
std::vector&lt; std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html">EdgeChildInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#aebe8cf2492abd66f1404a1bc6365fb11">edge_child_infos_</a></td></tr>
<tr class="memdesc:aebe8cf2492abd66f1404a1bc6365fb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">information about children of edges for each level <br /></td></tr>
<tr class="separator:aebe8cf2492abd66f1404a1bc6365fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5c2d0e57f0466d58971e11b3cf521f"><td class="memItemLeft" align="right" valign="top"><a id="a8e5c2d0e57f0466d58971e11b3cf521f"></a>
std::vector&lt; std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html">CellChildInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a8e5c2d0e57f0466d58971e11b3cf521f">cell_child_infos_</a></td></tr>
<tr class="memdesc:a8e5c2d0e57f0466d58971e11b3cf521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">information about children of cells for each level <br /></td></tr>
<tr class="separator:a8e5c2d0e57f0466d58971e11b3cf521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffcd6b15ca29cf2c5f05e3825d936d3"><td class="memItemLeft" align="right" valign="top"><a id="a8ffcd6b15ca29cf2c5f05e3825d936d3"></a>
std::vector&lt; std::array&lt; std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_parent_info.html">ParentInfo</a> &gt;, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a8ffcd6b15ca29cf2c5f05e3825d936d3">parent_infos_</a></td></tr>
<tr class="memdesc:a8ffcd6b15ca29cf2c5f05e3825d936d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">information about parent entities on each level <br /></td></tr>
<tr class="separator:a8ffcd6b15ca29cf2c5f05e3825d936d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927ab61efd7efabbf8cf8fb46b379c42"><td class="memItemLeft" align="right" valign="top"><a id="a927ab61efd7efabbf8cf8fb46b379c42"></a>
std::vector&lt; std::vector&lt; bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a927ab61efd7efabbf8cf8fb46b379c42">edge_marked_</a></td></tr>
<tr class="memdesc:a927ab61efd7efabbf8cf8fb46b379c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about marked edges. <br /></td></tr>
<tr class="separator:a927ab61efd7efabbf8cf8fb46b379c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2e8359fa3b2a011cf700d0672e6144"><td class="memItemLeft" align="right" valign="top"><a id="a7e2e8359fa3b2a011cf700d0672e6144"></a>
std::vector&lt; std::vector&lt; sub_idx_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a7e2e8359fa3b2a011cf700d0672e6144">refinement_edges_</a></td></tr>
<tr class="memdesc:a7e2e8359fa3b2a011cf700d0672e6144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about local refinement edges of triangles. <br /></td></tr>
<tr class="separator:a7e2e8359fa3b2a011cf700d0672e6144"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A hierarchy of nested 2D hybrid meshes created by refinement. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac2c38516a94d8fb131703b519bfc3738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c38516a94d8fb131703b519bfc3738">&#9670;&nbsp;</a></span>MeshHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lf::refinement::MeshHierarchy::MeshHierarchy </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt;&#160;</td>
          <td class="paramname"><em>base_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html">mesh::MeshFactory</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh_factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize mesh hierarchy with an existing coarsest mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_mesh</td><td>valid pointer to <em>non-const</em> coarsest mesh </td></tr>
    <tr><td class="paramname">mesh_factory</td><td>factory object creating new meshes during refinement</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Stores shared pointer to coarsest mesh.</li>
<li>Sets <em>refinement edges</em> of all cells according to the longest-edge criterion.</li>
<li>Initializes <code>ChildInfo</code> data structures of all entities to indicate absence of children, since no refinement has been done yet.</li>
<li>Fills void <code><a class="el" href="structlf_1_1refinement_1_1_parent_info.html" title="Information about possible parent entities. ">ParentInfo</a></code> data structure, since the mesh has not been created by refinement.</li>
<li>Unmarks all edges, see <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a693d5d31b5aaf0b9e077d890f3062022" title="Conduct local refinement of the mesh splitting all marked edges. ">RefineMarked()</a>. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a334d3018f4bad589a6a81e52df16e178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334d3018f4bad589a6a81e52df16e178">&#9670;&nbsp;</a></span>CellChildInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html">CellChildInfo</a>&gt;&amp; lf::refinement::MeshHierarchy::CellChildInfos </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain refinement information for all. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector for <a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html" title="Information about the refinement status of a cell. ">CellChildInfo</a> record for every node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html" title="Information about the refinement status of a cell. ">CellChildInfo</a> </dd></dl>

</div>
</div>
<a id="ab71cfa216aa13d280d814894811b09b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71cfa216aa13d280d814894811b09b2">&#9670;&nbsp;</a></span>Coarsen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::Coarsen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Destroy</em> the mesh on the finest level unless it is the base mesh </p>
<dl class="section note"><dt>Note</dt><dd>the use of shared pointers prevents destruction if the finest mesh is still in use somewhere else in the code. </dd></dl>

</div>
</div>
<a id="a0fe86a285de7b155b4eabc7233cba4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe86a285de7b155b4eabc7233cba4a5">&#9670;&nbsp;</a></span>EdgeChildInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html">EdgeChildInfo</a>&gt;&amp; lf::refinement::MeshHierarchy::EdgeChildInfos </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain refinement information for all edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector for <a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html" title="Information about the refinement status of an edge. ">EdgeChildInfo</a> record for every node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html" title="Information about the refinement status of an edge. ">EdgeChildInfo</a> </dd></dl>

</div>
</div>
<a id="af6af114a5d79f8cf99ed0d501dd417c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6af114a5d79f8cf99ed0d501dd417c1">&#9670;&nbsp;</a></span>getMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a>&gt; lf::refinement::MeshHierarchy::getMesh </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the mesh on a particular level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>specifies level of interest, 0 stands for coarsest level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to mesh on specified level </dd></dl>

</div>
</div>
<a id="a94c5d43197587173c285f2689868bd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c5d43197587173c285f2689868bd9d">&#9670;&nbsp;</a></span>getMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a>&gt; lf::refinement::MeshHierarchy::getMesh </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the mesh on a particular level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>specifies level of interest, 0 stands for coarsest level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to mesh on specified level </dd></dl>

</div>
</div>
<a id="a43f47c1d0b430311541771d26dceec21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f47c1d0b430311541771d26dceec21">&#9670;&nbsp;</a></span>getMeshes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;const <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a>&gt; &gt; lf::refinement::MeshHierarchy::getMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides array of shared pointers to meshes contained in the hierarchy. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of shared pointers to <a class="el" href="namespacelf_1_1mesh.html" title="Defines a set of interface classes that define a mesh manager and provides mesh-related tools that bu...">lf::mesh</a>:Mesh objects </dd></dl>

</div>
</div>
<a id="a26a427ec75f53b43f76a2b7e4ef32d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a427ec75f53b43f76a2b7e4ef32d86">&#9670;&nbsp;</a></span>LongestEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sub_idx_t lf::refinement::MeshHierarchy::LongestEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the longest edge of a triangle. </p>
<p>This method is used for setting refinement edges on coarsest meshes. Called in the constructor of <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html" title="A hierarchy of nested 2D hybrid meshes created by refinement. ">MeshHierarchy</a>. </p>

</div>
</div>
<a id="aa4608cfc81660a615e4a23c1476b7a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4608cfc81660a615e4a23c1476b7a7d">&#9670;&nbsp;</a></span>MarkEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Marker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::MarkEdges </td>
          <td>(</td>
          <td class="paramtype">Marker &amp;&amp;&#160;</td>
          <td class="paramname"><em>marker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the edges of a mesh based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">marker</td><td>this should be functor of type <code>std::function&lt;bool(const Mesh &amp;,const Entity &amp;)&gt;</code> returning true if the passed edge is to be marked.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>marker</em> object also takes a reference to a mesh, because marking makes sense only for the finest level. The mesh on the finest level is provided to the marker object by the <code><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html" title="A hierarchy of nested 2D hybrid meshes created by refinement. ">MeshHierarchy</a></code>.</p>
<p>Of course, marking will always affect the finest mesh in hierarchy. </p>

</div>
</div>
<a id="a546b2981a5c074c72e56c4592a5f253d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546b2981a5c074c72e56c4592a5f253d">&#9670;&nbsp;</a></span>ParentInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structlf_1_1refinement_1_1_parent_info.html">ParentInfo</a>&gt;&amp; lf::refinement::MeshHierarchy::ParentInfos </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&#160;</td>
          <td class="paramname"><em>codim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch information about parents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level of interest </td></tr>
    <tr><td class="paramname">codim</td><td>co-dimension of entities to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector for <a class="el" href="structlf_1_1refinement_1_1_parent_info.html" title="Information about possible parent entities. ">ParentInfo</a> record for every entity</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf_1_1refinement_1_1_parent_info.html" title="Information about possible parent entities. ">ParentInfo</a> </dd></dl>

</div>
</div>
<a id="ac18f1c6c7d4cca9de0647287913509f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18f1c6c7d4cca9de0647287913509f8">&#9670;&nbsp;</a></span>PerformRefinement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::PerformRefinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new mesh according to refinement pattern provided for entities. </p>
<p>This function expects that the refinement patterns stored in the vectors <code>point_child_infos_</code>, <code>edge_child_infos_</code> and <code>cell_child_infos_</code> have been initialized consistently for the finest mesh. According to this information, refinement is carried out using the object pointed to by mesh_factory_ to created new entities by calling <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html#a1aca9d8378841d8c46d3db3b05284c00" title="Construct a mesh out of the specified nodes and elements. ">lf::mesh::MeshFactory::Build()</a>.</p>
<p>The vectors <code>point_child_infos_</code>, <code>edge_child_infos_</code> and <code>cell_child_infos_</code> will be augmented with information about the indices of the child entities contained in the newly created finest mesh.</p>
<p>This method relies on <a class="el" href="classlf_1_1geometry_1_1_geometry.html#ad3e58b9f80a6daa2ce19455e88e4ef94" title="Generate geometry objects for child entities created in the course of refinement. ...">lf::geometry::Geometry::ChildGeometry()</a> to obtain information about the shape fo child entities in the form of <a class="el" href="classlf_1_1geometry_1_1_geometry.html">lf::geometry::Geometry</a> objects.</p>
<p>The method also initializes the data vectors in <code>_parent_infos_</code> for the newly created now finest mesh. </p>

</div>
</div>
<a id="ac538ac9d7b9f1128a251ab17dbd125b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac538ac9d7b9f1128a251ab17dbd125b7">&#9670;&nbsp;</a></span>PointChildInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structlf_1_1refinement_1_1_point_child_info.html">PointChildInfo</a>&gt;&amp; lf::refinement::MeshHierarchy::PointChildInfos </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain refinement information for all points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector for <a class="el" href="structlf_1_1refinement_1_1_point_child_info.html" title="Information about the refinement status of a point. ">PointChildInfo</a> record for every node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf_1_1refinement_1_1_point_child_info.html" title="Information about the refinement status of a point. ">PointChildInfo</a> </dd></dl>

</div>
</div>
<a id="a9f54305170974cae0e5b42754bf6d98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f54305170974cae0e5b42754bf6d98d">&#9670;&nbsp;</a></span>PrintInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lf::refinement::MeshHierarchy::PrintInfo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output of information about the mesh hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream, can be <code>std::cout</code> or similar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream</dd></dl>
<p>The type of output is controlled by the <code>ctrl_</code> static control variable. If its second bit is set, the output function of the mesh class is used.</p>
<p>This is a rudimentary implementation and should be extended. </p>

</div>
</div>
<a id="a693d5d31b5aaf0b9e077d890f3062022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693d5d31b5aaf0b9e077d890f3062022">&#9670;&nbsp;</a></span>RefineMarked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::RefineMarked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conduct local refinement of the mesh splitting all marked edges. </p>
<p>This method creates a new mesh by selectively (locally) refining entities of the current finest mesh in the hierarchy. Refinement is controlled by the boolean vector edge_marked_ that indicates, which edges must be refined (= split) in the course of refinement.</p>
<h3>Algorithm</h3>
<ul>
<li>First all marked edges are labelled as "to be split".</li>
<li><p class="startli">REPEAT</p><ul>
<li>Set refinement pattern of all cells to accommodate edges to be split</li>
<li>Add "to be split" tag to edges according to local refinement pattern for cells</li>
</ul>
<p class="startli">UNTIL no <em>extra</em> edges had to be tagged as "to be split"</p>
</li>
</ul>
<p>For details please consult the comments in mesh_hierarchy.cc</p>
<p>This algorithm ends with a set of local refinement patterns for every entity that is compatible with a <em>conforming</em> finite element mesh, that is, hanging nodes are avoided. </p>

</div>
</div>
<a id="ae631d3d4b080210e7fe28b0cb18a6a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae631d3d4b080210e7fe28b0cb18a6a1b">&#9670;&nbsp;</a></span>RefinementEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sub_idx_t&gt;&amp; lf::refinement::MeshHierarchy::RefinementEdges </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access refinement edge indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of (local) sub-entity index of refinement edge for every cell </dd></dl>

</div>
</div>
<a id="a40f62ce5f838a648e584015fc712ab27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f62ce5f838a648e584015fc712ab27">&#9670;&nbsp;</a></span>RefineRegular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::RefineRegular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelf_1_1refinement.html#aad00cb5a8084400b931b01984d2cdc5d">RefPat</a>&#160;</td>
          <td class="paramname"><em>ref_pat</em> = <code>RefPat::rp_regular</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform regular or barycentric uniform refinement of the finest mesh in the hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_pat</td><td>selector for type of uniform refinement: default is rp_regular, rp_barycentric choses barycentric refinement.</td></tr>
  </table>
  </dd>
</dl>
<p>This method carries out uniform refinement of all cells of a mesh according to the <code>rp_regular</code> or <code>rp_barycentric</code> refinement patterns.</p>
<p>A new mesh is added to the bottom of the hierarchy by regularly refining the <em>finest mesh</em> in the hierarchy. Regular refinement means that every node is copied, every edge is split and every cell is subdivided into four or six smaller ones of the same shape.</p>
<p>Internally, this method flags all nodes as to be copied, all edges as to be split and all cells as to be refined according to the passed refinement pattern. Then it calls <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac18f1c6c7d4cca9de0647287913509f8" title="Create new mesh according to refinement pattern provided for entities. ">PerformRefinement()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/travis/build/craffael/lehrfempp/lib/lf/refinement/<a class="el" href="mesh__hierarchy_8h_source.html">mesh_hierarchy.h</a></li>
<li>/home/travis/build/craffael/lehrfempp/lib/lf/refinement/mesh_hierarchy.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
